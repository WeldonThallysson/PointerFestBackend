{"version":3,"sources":["../../../src/services/Purchases/purchasesGetAllService.ts","../../../src/prisma/index.ts","../../../src/utils/formatters/formatterDate.ts","../../../src/utils/validators/validatorPermissions.ts"],"sourcesContent":["import { MessagesError } from \"../../constants/messages.api\";\r\nimport prismaClient from \"../../prisma\";\r\nimport { formatterDateToIso } from \"../../utils/formatters/formatterDate\";\r\nimport { validatorPermissions } from \"../../utils/validators/validatorPermissions\";\r\n \r\ninterface IPurchasesGetAll {\r\n  idUserLogged: string;\r\n  idOtherUser?: string | null;\r\n  idMethodPayment: string;\r\n  codeVoucher?: string | null;\r\n  codePayment: string;\r\n  datePayment: string;\r\n  limit: number;\r\n  page: number;\r\n}\r\n\r\nclass PurchasesGetAllService {\r\n  async execute({\r\n    idUserLogged,\r\n    idOtherUser,\r\n    idMethodPayment,\r\n    codePayment,\r\n    codeVoucher,\r\n    datePayment,\r\n    limit,\r\n    page,\r\n  }: IPurchasesGetAll) {\r\n    // Verificar se o usuário existe\r\n    const userExists = await prismaClient.users.findFirst({\r\n      where: { id: idUserLogged },\r\n    });\r\n\r\n    if (!userExists) {\r\n      return {\r\n        data: {\r\n          message:\r\n            \"Não foi possível prosseguir com está ação, usuário responsavel não existe\",\r\n          status: 404,\r\n        },\r\n      };  \r\n    }  \r\n     \r\n    const responseValidation = validatorPermissions({\r\n        typeAccess: userExists.typeAccess,\r\n      });\r\n  \r\n      // Verifica permissão para acessar dependentes de outro usuário\r\n  if (idOtherUser && responseValidation === false) {\r\n        return {\r\n          data: {\r\n            message: \"Sua conta não tem permissão para buscar os vouchers de outro usuário.\",\r\n            status: 403,\r\n          },\r\n        };\r\n      }\r\n  \r\n // Define o `idUserToQuery` como `idOtherUser` se passado, caso contrário, usa `idUserLogged`\r\n    const idUserToQuery = idOtherUser ?? idUserLogged;\r\n    \r\n    const where: any = { idUser: idUserToQuery };\r\n    \r\n    if(codeVoucher) where.id = { \r\n     contains: codeVoucher,\r\n     mode: \"insensitive\" \r\n    }\r\n\r\n    if (codePayment)\r\n      where.codePayment = { contains: codePayment, mode: \"insensitive\" };\r\n    if (datePayment)\r\n      where.datePayment = { contains: datePayment, mode: \"insensitive\" };\r\n    \r\n    if (idMethodPayment)\r\n      where.idMethodPayment = {\r\n        contains: idMethodPayment,\r\n      };\r\n\r\n    const shouldPaginate = page !== undefined || limit !== undefined;\r\n    const skip = shouldPaginate ? ((page ?? 1) - 1) * (limit ?? 10) : undefined;\r\n    const take = shouldPaginate ? (limit ?? 10) : undefined;\r\n  \r\n    try {\r\n      const dataResponseVouchers = await prismaClient.purchases.findMany({\r\n        skip,\r\n        take: take,\r\n        where,\r\n        orderBy: { created_At: \"desc\" },\r\n        select: {\r\n          id: true,\r\n          idUser: true,\r\n          idMethodPayment: true,\r\n          methodsPayments:true, \r\n          codePayment: true,\r\n          codeReferencePayment: true,\r\n          datePayment: true,\r\n          totalPrice: true,\r\n          status: true,\r\n          products: true,\r\n          created_At: true,\r\n        },\r\n      });\r\n\r\n      const dataFormated = dataResponseVouchers.map((item) => {\r\n        return {\r\n          ...item,\r\n          products: typeof item.products === 'string' ? JSON.parse(item.products) : item.products,\r\n          datePayment: formatterDateToIso(item.datePayment),\r\n        };\r\n      });\r\n\r\n      const totalPurchases = await prismaClient.purchases.count({ where });\r\n      const totalPages = shouldPaginate ? Math.ceil(totalPurchases / (limit ?? 10)) : 1;\r\n\r\n      return {\r\n        data: {\r\n          items: dataFormated,\r\n          totalItems: totalPurchases,\r\n          totalPages: totalPages,\r\n          currentPage: shouldPaginate ? page ?? 1 : 1,\r\n          status: 200,\r\n        },\r\n      };\r\n    } catch (error: any) {\r\n      return {\r\n        data: {\r\n          message: `${MessagesError.GetAllMessageError}`,\r\n          error: error?.message,\r\n          status: 500,\r\n        },\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport { PurchasesGetAllService };\r\n","import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst prismaClient = new PrismaClient()\r\n\r\nexport default prismaClient;\r\n","import { format, parseISO } from \"date-fns\";\r\n\r\nexport const formatterDate = (date: string) => {\r\n    // Parseia a data no formato ISO\r\n    const formattedBirthDate = parseISO(date);\r\n    return formattedBirthDate; // Retorna o objeto Date\r\n}\r\n\r\nexport const formatterDateToIso = (date: Date | string) => {\r\n    const dateObject = typeof date === \"string\" ? parseISO(date) : date;\r\n    const formattedBirthDate = format(dateObject, \"yyyy-MM-dd\"); \r\n    return formattedBirthDate;\r\n};\r\n\r\nexport const formatterDateToString = (item: string | null) => {\r\n    if (item) {\r\n        // Divide a string de data no formato \"YYYY-MM-DD\"\r\n        const [year, month, day] = item.split('-'); \r\n        // Retorna a data formatada no formato \"DD/MM/YYYY\"\r\n        return `${day}/${month}/${year}`;\r\n    }\r\n    // Retorna null se o item for nulo\r\n    return null; \r\n};\r\n\r\n","import { TypesAccess } from \"../../keys/typeAccess/typesAccess\";\r\n\r\ninterface IValidatorPermissions {\r\n    typeAccess: string,\r\n}\r\n\r\n\r\nexport const validatorPermissions = ({typeAccess}: IValidatorPermissions) => {\r\n  return (typeAccess === TypesAccess.Owner || typeAccess === TypesAccess.Developer || typeAccess === TypesAccess.Master || typeAccess === TypesAccess.Admin)\r\n \r\n}\r\n"],"mappings":"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","names":[]}