{"version":3,"sources":["../../../src/services/Purchases/purchasesEditService.ts","../../../src/prisma/index.ts","../../../src/utils/formatters/formatterDate.ts"],"sourcesContent":["import { TypesMethodPayment, TypesMethodPaymentResponse } from \"../../keys/typeMethodPayment/typesAccess\";\r\nimport prismaClient from \"../../prisma\";\r\nimport { formatterDateToIso } from \"../../utils/formatters/formatterDate\"; \r\nimport { IProduct } from \"../../interface/interface.checkoutPaymentMethod\";\r\nimport { TypesAccess } from \"../../keys/typeAccess/typesAccess\";\r\nimport { Messages, MessagesError } from \"../../constants/messages.api\";\r\n\r\n\r\n \r\ninterface IPurchasesEdit {\r\n    id: string\r\n    idUserLogged: string\r\n    typeMethodPayment: string\r\n    datePayment: string\r\n    codePayment: string\r\n    codeReferencePayment: string\r\n    products: IProduct[]\r\n    totalPrice?: number | null\r\n}\r\n\r\nclass PurchasesEditService {\r\n  async execute({\r\n    id,\r\n    idUserLogged,\r\n    typeMethodPayment,\r\n    codeReferencePayment,\r\n    codePayment,\r\n    datePayment,\r\n    products,\r\n    totalPrice\r\n  }: IPurchasesEdit) { \r\n    if (\r\n      !id ||\r\n      !typeMethodPayment ||\r\n      !codePayment ||\r\n      !codeReferencePayment ||\r\n      !datePayment ||\r\n      !products\r\n    ) {\r\n      return {\r\n        data: {\r\n          message: \"Não foi possível prosseguir, as propriedades estão incorretas\",\r\n          fields: [\r\n            \"id\",\r\n            \"typeMethodPayment\",\r\n            \"codePayment\",\r\n            \"codeReferencePayment\",\r\n            \"datePayment\",\r\n            \"products\"\r\n          ],\r\n          status: 400,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Verificar se o usuário existe\r\n    const userExists = await prismaClient.users.findFirst({\r\n      where: { id: idUserLogged },\r\n    });\r\n\r\n    const userLoggedExists = await prismaClient.users.findFirst({\r\n      where: {\r\n        id: idUserLogged\r\n      }\r\n    })\r\n\r\n\r\n    const voucherExists = await prismaClient.purchases.findFirst({\r\n      where: { \r\n        id: id,\r\n        //idUser: idUserLogged\r\n      }\r\n  })\r\n\r\n    if(!voucherExists){\r\n      return {\r\n        data: {\r\n          message: \"Não foi possível prosseguir com esta ação, esse voucher não existe!.\",\r\n          status: 403,\r\n        },\r\n       }\r\n    }\r\n\r\n    if(voucherExists.idUser === idUserLogged && userLoggedExists?.typeAccess === TypesAccess.Admin){\r\n      return {\r\n        data: {\r\n          message: \"Sua conta não possui autorização para realizar esta ação, você não pode editar seu próprio voucher, apenas contas master.\",\r\n          status: 403,\r\n        },\r\n       }\r\n    }\r\n\r\n    if(!userLoggedExists){\r\n      return {\r\n        data: {\r\n          message: \"Não foi possível prosseguir com esta ação, o usuário responsável não existe!.\",\r\n          status: 403,\r\n        },\r\n       }\r\n    }\r\n\r\n    if (!userExists) {\r\n      return {\r\n        data: {\r\n          message: \"Usuário não cadastrado no sistema.\",\r\n          status: 403,\r\n        },\r\n      };\r\n    }\r\n    \r\n\r\n    \r\n    if(\r\n      userLoggedExists?.typeAccess !== TypesAccess.Owner && \r\n      userLoggedExists?.typeAccess !== TypesAccess.Developer &&\r\n      userLoggedExists?.typeAccess !== TypesAccess.Master){\r\n      return {\r\n        data: {\r\n          message: \"Não foi possível prosseguir, sua conta não possui permissão para esta ação apenas contas master!\",\r\n          status: 404,\r\n        },\r\n      }\r\n    }\r\n    \r\n    // Determinar o tipo de pagamento\r\n    let paymentMethod: string;\r\n\r\n    switch (typeMethodPayment) {\r\n      case TypesMethodPaymentResponse.AVISTA:\r\n      case TypesMethodPayment.AVISTA:\r\n        paymentMethod = \"avista\";\r\n        break;\r\n      case TypesMethodPaymentResponse.PIX:\r\n      case TypesMethodPayment.Pix:\r\n        paymentMethod = \"pix\";\r\n        break;\r\n      case TypesMethodPaymentResponse.CREDIT_CARD:\r\n      case TypesMethodPayment.Credit:\r\n        paymentMethod = \"credito\";\r\n        break;\r\n      case TypesMethodPaymentResponse.DEBIT_CARD:\r\n      case TypesMethodPayment.Debit:\r\n        paymentMethod = \"debito\";\r\n        break;\r\n      default:\r\n        return {\r\n          data: {\r\n            message: \"Método de pagamento inválido.\",\r\n            status: 400,\r\n          },\r\n        };\r\n    }\r\n\r\n    // Buscar se o método de pagamento existe no banco\r\n    const methodPaymentExists = await prismaClient.methodsPayments.findFirst({\r\n      where: { typeMethodPayment: paymentMethod },\r\n    });\r\n\r\n    if (!methodPaymentExists) {\r\n      return {\r\n        data: {\r\n          message: \"Método de pagamento não encontrado.\",\r\n          status: 404,\r\n        },\r\n      };\r\n    }\r\n\r\n    try {\r\n      await prismaClient.purchases.update({\r\n        where: {\r\n          id: id\r\n        },\r\n        data: {\r\n          products: JSON.stringify(products),\r\n          codePayment: codePayment,\r\n          codeReferencePayment: codeReferencePayment,\r\n          idUser: userExists.id,\r\n          idMethodPayment: methodPaymentExists.id,\r\n          datePayment: formatterDateToIso(datePayment),\r\n          totalPrice: totalPrice ? totalPrice : voucherExists.totalPrice,\r\n        },\r\n      });\r\n      \r\n      return {\r\n        data: {\r\n          message: Messages.UpdateMessageSuccess,\r\n          status: 201,\r\n        },\r\n      };\r\n    } \r\n    \r\n    catch (err) {\r\n      return {\r\n        data: {\r\n          message: `${MessagesError.UpdateMessageError} ${err}`,\r\n          error: err,\r\n          status: 500,\r\n        },\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport {PurchasesEditService};\r\n","import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst prismaClient = new PrismaClient()\r\n\r\nexport default prismaClient;\r\n","import { format, parseISO } from \"date-fns\";\r\n\r\nexport const formatterDate = (date: string) => {\r\n    // Parseia a data no formato ISO\r\n    const formattedBirthDate = parseISO(date);\r\n    return formattedBirthDate; // Retorna o objeto Date\r\n}\r\n\r\nexport const formatterDateToIso = (date: Date | string) => {\r\n    const dateObject = typeof date === \"string\" ? parseISO(date) : date;\r\n    const formattedBirthDate = format(dateObject, \"yyyy-MM-dd\"); \r\n    return formattedBirthDate;\r\n};\r\n\r\nexport const formatterDateToString = (item: string | null) => {\r\n    if (item) {\r\n        // Divide a string de data no formato \"YYYY-MM-DD\"\r\n        const [year, month, day] = item.split('-'); \r\n        // Retorna a data formatada no formato \"DD/MM/YYYY\"\r\n        return `${day}/${month}/${year}`;\r\n    }\r\n    // Retorna null se o item for nulo\r\n    return null; \r\n};\r\n\r\n"],"mappings":"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","names":[]}