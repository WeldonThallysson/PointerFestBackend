{"version":3,"sources":["../../../src/services/Purchases/purchesesGetDetailsService.ts","../../../src/prisma/index.ts","../../../src/utils/formatters/formatterDate.ts","../../../src/utils/validators/validatorPermissions.ts"],"sourcesContent":["import { MessagesError } from \"../../constants/messages.api\";\r\nimport prismaClient from \"../../prisma\";\r\nimport { formatterDateToIso } from \"../../utils/formatters/formatterDate\";\r\nimport { validatorPermissions } from \"../../utils/validators/validatorPermissions\";\r\n\r\ninterface IGetDetailsVoucher {\r\n  idUserLogged: string;\r\n  id: string;\r\n  idOtherUser?: string | null; // Novo campo opcional\r\n}\r\n\r\nclass GetDetailsVoucherService {\r\n  async execute({\r\n    id,\r\n    idUserLogged,\r\n    idOtherUser,\r\n  }: IGetDetailsVoucher) {\r\n    if (!id) {\r\n      return {\r\n        data: {\r\n          message: \"Não foi possível prosseguir com está ação, id do voucher não informado\",\r\n          status: 400,\r\n        },\r\n      };\r\n    }\r\n\r\n    if (!idUserLogged) {\r\n      return {\r\n        data: {\r\n          message: \"Não foi possível prosseguir com está ação, id do responsável não informado\",\r\n          status: 400,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Verifica se o voucher existe\r\n    const voucherExists = await prismaClient.purchases.findFirst({\r\n      where: { id },\r\n    });\r\n\r\n    if (!voucherExists) {\r\n      return {\r\n        data: {\r\n          message: \"Não foi possível prosseguir, o voucher não foi emitido e não existe.\",\r\n          status: 404,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Verifica se o usuário logado existe\r\n    const userExists = await prismaClient.users.findFirst({\r\n      where: { id: idUserLogged },\r\n    });\r\n\r\n    if (!userExists) {\r\n      return {\r\n        data: {\r\n          message: \"Não foi possível prosseguir com está ação, usuário responsável não existe\",\r\n          status: 404,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Verifica as permissões do usuário\r\n    const responseValidation = validatorPermissions({\r\n      typeAccess: userExists.typeAccess,\r\n    });\r\n\r\n    // Se idOtherUser for fornecido, valida se o usuário logado tem permissão\r\n    if (idOtherUser && responseValidation === false) {\r\n      return {\r\n        data: {\r\n          message: \"Sua conta não tem permissão para buscar os detalhes do voucher de outro usuário.\",\r\n          status: 403,\r\n        },\r\n      };\r\n    }\r\n    // Define o `idUserToQuery` como `idOtherUser` se passado, caso contrário, usa `idUserLogged`\r\n    const idUserToQuery = idOtherUser ?? idUserLogged;\r\n\r\n    try {\r\n      // Busca os detalhes do voucher\r\n      const dataResponseVoucher = await prismaClient.purchases.findFirst({\r\n        where: {\r\n          id,\r\n          idUser: idUserToQuery, \r\n        },\r\n        select: {\r\n          id: true,\r\n          idUser: true,\r\n          idMethodPayment: true,\r\n          codePayment: true,\r\n          methodsPayments:true, \r\n          codeReferencePayment: true,\r\n          datePayment: true,\r\n          totalPrice: true,\r\n          status: true,\r\n          products: true,\r\n          created_At: true,\r\n        },\r\n      });\r\n\r\n      if (!dataResponseVoucher) {\r\n        return {\r\n          data: {\r\n            message: \"Não foi possível prosseguir com está ação, essa compra não existe!\",\r\n            status: 404,\r\n          },\r\n        };\r\n      }\r\n      \r\n      // Formata os dados do voucher\r\n      const dataDetailsVoucherFormated = {\r\n        ...dataResponseVoucher,\r\n        products: typeof dataResponseVoucher?.products === 'string' ? JSON.parse(dataResponseVoucher.products) : dataResponseVoucher.products,\r\n        datePayment: formatterDateToIso(dataResponseVoucher.datePayment),\r\n      };\r\n\r\n      return {\r\n        data: {\r\n          items: {\r\n            dataDetailsVoucherFormated,\r\n          },\r\n          status: 200,\r\n        },\r\n      };\r\n    } catch (error: any) {\r\n      return {\r\n        data: {\r\n          message: MessagesError.GetDetailsMessageError,\r\n          error: error?.message,\r\n          status: 500,\r\n        },\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport { GetDetailsVoucherService };\r\n","import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst prismaClient = new PrismaClient()\r\n\r\nexport default prismaClient;\r\n","import { format, parseISO } from \"date-fns\";\r\n\r\nexport const formatterDate = (date: string) => {\r\n    // Parseia a data no formato ISO\r\n    const formattedBirthDate = parseISO(date);\r\n    return formattedBirthDate; // Retorna o objeto Date\r\n}\r\n\r\nexport const formatterDateToIso = (date: Date | string) => {\r\n    const dateObject = typeof date === \"string\" ? parseISO(date) : date;\r\n    const formattedBirthDate = format(dateObject, \"yyyy-MM-dd\"); \r\n    return formattedBirthDate;\r\n};\r\n\r\nexport const formatterDateToString = (item: string | null) => {\r\n    if (item) {\r\n        // Divide a string de data no formato \"YYYY-MM-DD\"\r\n        const [year, month, day] = item.split('-'); \r\n        // Retorna a data formatada no formato \"DD/MM/YYYY\"\r\n        return `${day}/${month}/${year}`;\r\n    }\r\n    // Retorna null se o item for nulo\r\n    return null; \r\n};\r\n\r\n","import { TypesAccess } from \"../../keys/typeAccess/typesAccess\";\r\n\r\ninterface IValidatorPermissions {\r\n    typeAccess: string,\r\n}\r\n\r\n\r\nexport const validatorPermissions = ({typeAccess}: IValidatorPermissions) => {\r\n  return (typeAccess === TypesAccess.Owner || typeAccess === TypesAccess.Developer || typeAccess === TypesAccess.Master || typeAccess === TypesAccess.Admin)\r\n \r\n}\r\n"],"mappings":"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","names":[]}